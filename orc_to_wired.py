# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_flow_orc_to_wired__switch_addflow_flow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/addflow/flow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_src','__ip_dst','__port',)

  _yang_name = 'flow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    self.__ip_src = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__ip_dst = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'addflow', 'flow']

  def _get_ip_src(self):
    """
    Getter method for ip_src, mapped from YANG variable /switch/addflow/flow/ip_src (ipv4-address)
    """
    return self.__ip_src
      
  def _set_ip_src(self, v, load=False):
    """
    Setter method for ip_src, mapped from YANG variable /switch/addflow/flow/ip_src (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_src is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_src() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_src must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_src = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_src(self):
    self.__ip_src = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_ip_dst(self):
    """
    Getter method for ip_dst, mapped from YANG variable /switch/addflow/flow/ip_dst (ipv4-address)
    """
    return self.__ip_dst
      
  def _set_ip_dst(self, v, load=False):
    """
    Setter method for ip_dst, mapped from YANG variable /switch/addflow/flow/ip_dst (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_dst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_dst() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_dst must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_dst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_dst(self):
    self.__ip_dst = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /switch/addflow/flow/port (port-number)
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /switch/addflow/flow/port (port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with port-number""",
          'defined-type': "orc_to_wired:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)

  ip_src = __builtin__.property(_get_ip_src, _set_ip_src)
  ip_dst = __builtin__.property(_get_ip_dst, _set_ip_dst)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('ip_src', ip_src), ('ip_dst', ip_dst), ('port', port), ])


class yc_addflow_orc_to_wired__switch_addflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/addflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flow',)

  _yang_name = 'addflow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flow = YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_addflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'addflow']

  def _get_flow(self):
    """
    Getter method for flow, mapped from YANG variable /switch/addflow/flow (list)
    """
    return self.__flow
      
  def _set_flow(self, v, load=False):
    """
    Setter method for flow, mapped from YANG variable /switch/addflow/flow (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port",yc_flow_orc_to_wired__switch_addflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_addflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)""",
        })

    self.__flow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow(self):
    self.__flow = YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_addflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

  flow = __builtin__.property(_get_flow, _set_flow)


  _pyangbind_elements = OrderedDict([('flow', flow), ])


class yc_flow_orc_to_wired__switch_deleteflow_flow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/deleteflow/flow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_src','__ip_dst','__port',)

  _yang_name = 'flow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    self.__ip_src = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__ip_dst = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'deleteflow', 'flow']

  def _get_ip_src(self):
    """
    Getter method for ip_src, mapped from YANG variable /switch/deleteflow/flow/ip_src (ipv4-address)
    """
    return self.__ip_src
      
  def _set_ip_src(self, v, load=False):
    """
    Setter method for ip_src, mapped from YANG variable /switch/deleteflow/flow/ip_src (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_src is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_src() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_src must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_src = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_src(self):
    self.__ip_src = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_ip_dst(self):
    """
    Getter method for ip_dst, mapped from YANG variable /switch/deleteflow/flow/ip_dst (ipv4-address)
    """
    return self.__ip_dst
      
  def _set_ip_dst(self, v, load=False):
    """
    Setter method for ip_dst, mapped from YANG variable /switch/deleteflow/flow/ip_dst (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_dst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_dst() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_dst must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_dst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_dst(self):
    self.__ip_dst = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /switch/deleteflow/flow/port (port-number)
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /switch/deleteflow/flow/port (port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with port-number""",
          'defined-type': "orc_to_wired:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)

  ip_src = __builtin__.property(_get_ip_src, _set_ip_src)
  ip_dst = __builtin__.property(_get_ip_dst, _set_ip_dst)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('ip_src', ip_src), ('ip_dst', ip_dst), ('port', port), ])


class yc_deleteflow_orc_to_wired__switch_deleteflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/deleteflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flow',)

  _yang_name = 'deleteflow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flow = YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_deleteflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'deleteflow']

  def _get_flow(self):
    """
    Getter method for flow, mapped from YANG variable /switch/deleteflow/flow (list)
    """
    return self.__flow
      
  def _set_flow(self, v, load=False):
    """
    Setter method for flow, mapped from YANG variable /switch/deleteflow/flow (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port",yc_flow_orc_to_wired__switch_deleteflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_deleteflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)""",
        })

    self.__flow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow(self):
    self.__flow = YANGDynClass(base=YANGListType("port",yc_flow_orc_to_wired__switch_deleteflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

  flow = __builtin__.property(_get_flow, _set_flow)


  _pyangbind_elements = OrderedDict([('flow', flow), ])


class yc_flow_orc_to_wired__switch_changeflow_flow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/changeflow/flow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_src_old','__ip_dst_old','__port_old','__ip_src_new','__ip_dst_new','__port_new',)

  _yang_name = 'flow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_src_old = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__ip_dst_old = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__ip_dst_new = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__ip_src_new = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    self.__port_new = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    self.__port_old = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'changeflow', 'flow']

  def _get_ip_src_old(self):
    """
    Getter method for ip_src_old, mapped from YANG variable /switch/changeflow/flow/ip_src_old (ipv4-address)
    """
    return self.__ip_src_old
      
  def _set_ip_src_old(self, v, load=False):
    """
    Setter method for ip_src_old, mapped from YANG variable /switch/changeflow/flow/ip_src_old (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_src_old is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_src_old() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_src_old must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_src_old = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_src_old(self):
    self.__ip_src_old = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_ip_dst_old(self):
    """
    Getter method for ip_dst_old, mapped from YANG variable /switch/changeflow/flow/ip_dst_old (ipv4-address)
    """
    return self.__ip_dst_old
      
  def _set_ip_dst_old(self, v, load=False):
    """
    Setter method for ip_dst_old, mapped from YANG variable /switch/changeflow/flow/ip_dst_old (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_dst_old is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_dst_old() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_dst_old must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_dst_old = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_dst_old(self):
    self.__ip_dst_old = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_port_old(self):
    """
    Getter method for port_old, mapped from YANG variable /switch/changeflow/flow/port_old (port-number)
    """
    return self.__port_old
      
  def _set_port_old(self, v, load=False):
    """
    Setter method for port_old, mapped from YANG variable /switch/changeflow/flow/port_old (port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_old is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_old() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_old must be of a type compatible with port-number""",
          'defined-type': "orc_to_wired:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)""",
        })

    self.__port_old = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_old(self):
    self.__port_old = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_old", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)


  def _get_ip_src_new(self):
    """
    Getter method for ip_src_new, mapped from YANG variable /switch/changeflow/flow/ip_src_new (ipv4-address)
    """
    return self.__ip_src_new
      
  def _set_ip_src_new(self, v, load=False):
    """
    Setter method for ip_src_new, mapped from YANG variable /switch/changeflow/flow/ip_src_new (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_src_new is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_src_new() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_src_new must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_src_new = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_src_new(self):
    self.__ip_src_new = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_src_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_ip_dst_new(self):
    """
    Getter method for ip_dst_new, mapped from YANG variable /switch/changeflow/flow/ip_dst_new (ipv4-address)
    """
    return self.__ip_dst_new
      
  def _set_ip_dst_new(self, v, load=False):
    """
    Setter method for ip_dst_new, mapped from YANG variable /switch/changeflow/flow/ip_dst_new (ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_dst_new is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_dst_new() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_dst_new must be of a type compatible with ipv4-address""",
          'defined-type': "orc_to_wired:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)""",
        })

    self.__ip_dst_new = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_dst_new(self):
    self.__ip_dst_new = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip_dst_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='ipv4-address', is_config=True)


  def _get_port_new(self):
    """
    Getter method for port_new, mapped from YANG variable /switch/changeflow/flow/port_new (port-number)
    """
    return self.__port_new
      
  def _set_port_new(self, v, load=False):
    """
    Setter method for port_new, mapped from YANG variable /switch/changeflow/flow/port_new (port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_new is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_new() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_new must be of a type compatible with port-number""",
          'defined-type': "orc_to_wired:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)""",
        })

    self.__port_new = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_new(self):
    self.__port_new = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port_new", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='port-number', is_config=True)

  ip_src_old = __builtin__.property(_get_ip_src_old, _set_ip_src_old)
  ip_dst_old = __builtin__.property(_get_ip_dst_old, _set_ip_dst_old)
  port_old = __builtin__.property(_get_port_old, _set_port_old)
  ip_src_new = __builtin__.property(_get_ip_src_new, _set_ip_src_new)
  ip_dst_new = __builtin__.property(_get_ip_dst_new, _set_ip_dst_new)
  port_new = __builtin__.property(_get_port_new, _set_port_new)


  _pyangbind_elements = OrderedDict([('ip_src_old', ip_src_old), ('ip_dst_old', ip_dst_old), ('port_old', port_old), ('ip_src_new', ip_src_new), ('ip_dst_new', ip_dst_new), ('port_new', port_new), ])


class yc_changeflow_orc_to_wired__switch_changeflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch/changeflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flow',)

  _yang_name = 'changeflow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flow = YANGDynClass(base=YANGListType("port_old",yc_flow_orc_to_wired__switch_changeflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port_old', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch', 'changeflow']

  def _get_flow(self):
    """
    Getter method for flow, mapped from YANG variable /switch/changeflow/flow (list)
    """
    return self.__flow
      
  def _set_flow(self, v, load=False):
    """
    Setter method for flow, mapped from YANG variable /switch/changeflow/flow (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port_old",yc_flow_orc_to_wired__switch_changeflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port_old', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port_old",yc_flow_orc_to_wired__switch_changeflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port_old', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)""",
        })

    self.__flow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow(self):
    self.__flow = YANGDynClass(base=YANGListType("port_old",yc_flow_orc_to_wired__switch_changeflow_flow, yang_name="flow", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port_old', extensions=None), is_container='list', yang_name="flow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='list', is_config=True)

  flow = __builtin__.property(_get_flow, _set_flow)


  _pyangbind_elements = OrderedDict([('flow', flow), ])


class yc_switch_orc_to_wired__switch(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /switch. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addflow','__deleteflow','__changeflow',)

  _yang_name = 'switch'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__deleteflow = YANGDynClass(base=yc_deleteflow_orc_to_wired__switch_deleteflow, is_container='container', yang_name="deleteflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    self.__changeflow = YANGDynClass(base=yc_changeflow_orc_to_wired__switch_changeflow, is_container='container', yang_name="changeflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    self.__addflow = YANGDynClass(base=yc_addflow_orc_to_wired__switch_addflow, is_container='container', yang_name="addflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['switch']

  def _get_addflow(self):
    """
    Getter method for addflow, mapped from YANG variable /switch/addflow (container)
    """
    return self.__addflow
      
  def _set_addflow(self, v, load=False):
    """
    Setter method for addflow, mapped from YANG variable /switch/addflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addflow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addflow_orc_to_wired__switch_addflow, is_container='container', yang_name="addflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addflow_orc_to_wired__switch_addflow, is_container='container', yang_name="addflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)""",
        })

    self.__addflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addflow(self):
    self.__addflow = YANGDynClass(base=yc_addflow_orc_to_wired__switch_addflow, is_container='container', yang_name="addflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)


  def _get_deleteflow(self):
    """
    Getter method for deleteflow, mapped from YANG variable /switch/deleteflow (container)
    """
    return self.__deleteflow
      
  def _set_deleteflow(self, v, load=False):
    """
    Setter method for deleteflow, mapped from YANG variable /switch/deleteflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deleteflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deleteflow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_deleteflow_orc_to_wired__switch_deleteflow, is_container='container', yang_name="deleteflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deleteflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_deleteflow_orc_to_wired__switch_deleteflow, is_container='container', yang_name="deleteflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)""",
        })

    self.__deleteflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deleteflow(self):
    self.__deleteflow = YANGDynClass(base=yc_deleteflow_orc_to_wired__switch_deleteflow, is_container='container', yang_name="deleteflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)


  def _get_changeflow(self):
    """
    Getter method for changeflow, mapped from YANG variable /switch/changeflow (container)
    """
    return self.__changeflow
      
  def _set_changeflow(self, v, load=False):
    """
    Setter method for changeflow, mapped from YANG variable /switch/changeflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_changeflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_changeflow() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_changeflow_orc_to_wired__switch_changeflow, is_container='container', yang_name="changeflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """changeflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_changeflow_orc_to_wired__switch_changeflow, is_container='container', yang_name="changeflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)""",
        })

    self.__changeflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_changeflow(self):
    self.__changeflow = YANGDynClass(base=yc_changeflow_orc_to_wired__switch_changeflow, is_container='container', yang_name="changeflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)

  addflow = __builtin__.property(_get_addflow, _set_addflow)
  deleteflow = __builtin__.property(_get_deleteflow, _set_deleteflow)
  changeflow = __builtin__.property(_get_changeflow, _set_changeflow)


  _pyangbind_elements = OrderedDict([('addflow', addflow), ('deleteflow', deleteflow), ('changeflow', changeflow), ])


class orc_to_wired(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module orc_to_wired - based on the path /orc_to_wired. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__switch',)

  _yang_name = 'orc_to_wired'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__switch = YANGDynClass(base=yc_switch_orc_to_wired__switch, is_container='container', yang_name="switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_switch(self):
    """
    Getter method for switch, mapped from YANG variable /switch (container)
    """
    return self.__switch
      
  def _set_switch(self, v, load=False):
    """
    Setter method for switch, mapped from YANG variable /switch (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switch() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_switch_orc_to_wired__switch, is_container='container', yang_name="switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switch must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_switch_orc_to_wired__switch, is_container='container', yang_name="switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)""",
        })

    self.__switch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switch(self):
    self.__switch = YANGDynClass(base=yc_switch_orc_to_wired__switch, is_container='container', yang_name="switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://wired.com/orc_to_wired', defining_module='orc_to_wired', yang_type='container', is_config=True)

  switch = __builtin__.property(_get_switch, _set_switch)


  _pyangbind_elements = OrderedDict([('switch', switch), ])


